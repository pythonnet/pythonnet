<html>
<head>

<title>Python for .NET</title>

<style type="text/css"><!--

body { 
  font: 8pt/16pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
  background: #ffffff;
  margin: 0px; 
}

p { 
  font: 8pt/16pt georgia; 
}

h1 { 
  font: bold 14pt;
  color: #000044;
/*
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
*/
}

h2 { 
  font: bold 14pt;
  margin-bottom: 0px; 
  color: #000044;
}

h3 { 
  font: bold 12pt;
  margin-bottom: 0px;
  color: #000044; 
}

a:link { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:visited { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:hover, a:active { 
  text-decoration: underline; 
  color: #000066;
}

pre {
  font-family: monospace;
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
}

li { 
  font: 8pt/16pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
}

.spacer {
  font: bold 14pt;
}

.menu {
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
  font-size: x-small;
}

.menu ul {
  margin: 0px;
  padding: 0px;
}

//--></style>

</head>
<body>

<table width="98%" border="0" cellspacing="4">

<tr>
  <td align="left" valign="top" width="20%" class="menu">

  <h1>Python for .NET</h1>

  <ul>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#getting_started">Getting Started</a></li>
  <li><a href="#importing">Importing Modules</a></li>
  <li><a href="#classes">Using Classes</a></li>
  <li><a href="#generics">Using Generics</a></li>
  <li><a href="#fields">Fields and Properties</a></li>
  <li><a href="#indexers">Using Indexers</a></li>
  <li><a href="#methods">Using Methods</a></li>
  <li><a href="#genericmethods">Overloaded and Generic Methods</a></li>
  <li><a href="#delegates">Delegates and Events</a></li>
  <li><a href="#exceptions">Exception Handling</a></li>
  <li><a href="#arrays">Using Arrays</a></li>
  <li><a href="#collections">Using Collections</a></li>
  <li><a href="#com">COM Components</a></li>
  <li><a href="#types">Type Conversion</a></li>
  <li><a href="#embedding">Embedding Python</a></li>
  <li><a href="#license">License</a></li>
  </ul>

  </td>

  <td align="left" valign="top">
  


<p>  
 Python for .NET is a package that gives Python programmers nearly seamless 
 integration with the .NET Common Language Runtime (CLR) and provides a 
 powerful application scripting tool for .NET developers. Using this package 
 you can script .NET applications or build entire applications in Python, 
 using .NET services and components written in any language that targets the 
 CLR (Managed C++, C#, VB, JScript).
</p>

<p>
 Note that this package does <em>not</em> implement Python as a first-class 
 CLR language - it does not produce managed code (IL) from Python code. 
 Rather, it is an integration of the C Python engine with the .NET runtime. 
 This approach allows you to use use CLR services and continue to use existing 
 Python code and C-based extensions while maintaining native execution speeds 
 for Python code. If you are interested in a pure managed-code implementation 
 of the Python language, you should check out the 
 <a href="http://www.ironpython.com">IronPython</a> project, which is in 
 active development.
</p>

<p>
 Python for .NET is currently compatible with Python releases 2.4 and 2.5. 
 Current releases are available at the 
 <a href="http://pythonnet.sourceforge.net/">
 Python for .NET website
 </a>. To subscribe to the 
 <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
 Python for .NET mailing list 
 </a> or read the 
 <a href="http://mail.python.org/pipermail/pythondotnet/">
 online archives
 </a> of the list, see the 
 <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
 mailing list information
 </a> page. 
</p>


<a name="#installation"></a>

<h2>Installation</h2>

<p>
 Python for .NET is available as a source release and as a Windows installer 
 for various versions of Python and the common language runtime from the 
 <a href="http://pythonnet.sourceforge.net/">
 Python for .NET website
 </a>. On Windows platforms, you can choose to install .NET-awareness into 
 an existing Python installation as well as install Python for .NET as a 
 standalone package.
</p>

<p>   
 The source release is a self-contained "private" assembly. 
 Just unzip the package wherever you want it, cd to that directory and run 
 python.exe to start using it. Note that the source release does not 
 include a copy of the CPython runtime, so you will need to have installed 
 Python on your machine before using the source release.
</p>

<p>
 <strong>Running on Linux/Mono:</strong> Preliminary testing shows that 
 PythonNet runs under <a href="http://www.go-mono.com">Mono</a> without
 major issues, though the Mono runtime is not yet complete so there 
 still may be problems. The only known issues with Mono are related to
 generic methods. Some edge cases aren't working properly and the bugs
 are already been worked on. However the Python for .NET integration layer
 is 100% managed code, so there should be no long-term issues under Mono
 - it should work better and better as the Mono platform matures.
</p>

<p>
 With Mono 1.2.3 and greater it is possible to build PythonNet under Mono.
 You need to install the Mono suite including the gmcs compiler for .Net
 2.0 and mono-dev for the header files headers. The latter is only
 required if you want to build the tools in src/monoclr.
</p>

<p>
 <strong>Note:</strong> Although in theory a Python.Runtime.dll build
 with Microsoft Visual C# should work under Linux/Mono it doesn't work
 in pratice due a conflict between UCS-2 and UCS-4 unicode representation.
 Windows build of Python store unicode as 2 byte objects while most Linux
 distributions build Python with UCS-4. UCS-4 builds of PythonNet require
 Mono specific libraries.
</p>

<p>
  Note that if you are running under Mono on a *nix system, you will need 
 to have a compatible version of Python installed. You will also need 
 to create a symbolic link to the copy of libpython2.x.so (in your existing 
 Python installation) in the PythonNet directory. This is needed to ensure 
 that the mono interop dll loader will find it by name. For example:
 to have a compatible version of Python installed. You'll also have to
 add some aliases to either ~/.mono/config or /etc/mono/config so Mono can
 find the python25.dll. The doc/ directory contains a sample
</p>
 
<p>
 You can use the clr.so extension to add PythonNet to a standard Python 
 interpreter on *nix. Either you have to copy Python.Runtime.dll next to
 binary or you have to use the GAC. clr.so does <strong>NOT</strong> work
 when the interpreter is not build with --enable-shared (Debian, Ubuntu)
 or libpython2.?.so isn't available. You <strong>must</strong> use a
 Python binary that is linked dynamically against libpython2.?.so.
 <code>ldd /usr/bin/python2.?</code> has to list <code>libpython2.?.so</code>. When your
 Python interpreter isn't linked against libpython2.?.so you can't load
 the clr.so module. The src/monoclr/ directory contains a dynamically linked
 Python binary and a clrpython2.x which automatically loads Mono and PythonNet
 on startup.
</p>

 <pre>
    &lt;dllmap dll="python25" target="libpython2.5.so" os="!windows" /&gt;
 </pre>
 
<a name="monoclr_libpython"><a/>
<p>
 PythonNet uses compiler symbols in order to build PythonNet for different
 versions and flavors of Python.
 <table>
  <tr><th>symbol</th><th>explenetion</th></tr>
  <tr><td>PYTHON23</td><td>build for Python 2.3</td></tr>
  <tr><td>PYTHON24</td><td>build for Python 2.4</td></tr>
  <tr><td>PYTHON25</td><td>build for Python 2.5</td></tr>
  <tr><td>PYTHON26</td><td>build for Python 2.6</td></tr>
  <tr><td>UCS2</td><td>For Python compiled with --enable-unicode=ucs2 (default)</td></tr>
  <tr><td>UCS4</td><td>For Python compiled with --enable-unicode=ucs4</td></tr>
  <tr><td>Py_DEBUG</td><td>For Python debug builds (not yet implemented)</td></tr>
  <tr><td>DEBUG</td><td>Additional debugging (doesn't require Py_DEBUG)</td></tr>
  <tr><td>TRACE</td><td>Not used</td></tr>
</table>
</p>


<a name="getting_started"></a>

<h2>Getting Started</h2>

<p>
 A key goal for this project has been that Python for .NET should &quot;work 
 just the way you'd expect in Python&quot;, except for cases that are .NET 
 specific (in which case the goal is to work &quot;just the way you'd expect 
 in C#&quot;). In addition, with the IronPython project gaining traction, it 
 is my goal that code written for IronPython run without modification under 
 Python for .NET.
</p>

<p>
 If you already know Python, you can probably finish this readme and then 
 refer to .NET docs to figure out anything you need to do. Conversely if 
 you are familiar with C# or another .NET language, you probably just 
 need to pick up one of the many good Python books or read the Python 
 tutorial online to get started.
</p>

<p>
 A good way to start is to run <strong>python.exe</strong> and follow along 
 with the examples in this document. If you get stuck, there are also a 
 number of demos and unit tests located in the source directory of the 
 distribution that can be helpful as examples.
</p>

<p>
 Note that if you have installed CLR support into your existing Python 
 installation (rather than using the included python.exe), you will need 
 to use the line: &quot'import clr&quot; (lower-case!) to initially load 
 the clr extension module before trying the following examples.
</p>

<a name="importing"></a>

<h2>Importing Modules</h2>

<p>      
 Python for .NET allows CLR namespaces to be treated essentially as 
 Python packages. 
<p>

<pre>
    from System import String
    from System.Collections import *
</pre>

<p>
<em>
 Note that earlier releases of Python for .NET required you to import modules 
 through a special top-level package named <code>CLR</code>. This is no longer 
 required, though the syntax is still supported for backward compatibility.
</em>
</p>

<p>      
 Types from any loaded assembly may be imported and used in this manner. To 
 load an assembly, use the "AddReference" function in the "clr" module:
</p>

<pre>

    import clr
    clr.AddReference("System.Windows.Forms")
    from System.Windows.Forms import Form

</pre>

<p>
<em>
 Note that earlier releases of Python for .NET relied on "implicit loading" 
 to support automatic loading of assemblies whose names corresponded to an 
 imported namespace. Implicit loading still works for backward compatibility, 
 but will be removed in a future release so it is recommended to use the 
 clr.AddReference method.
</em>
</p>

<p>
 Python for .NET uses the PYTHONPATH (sys.path) to look for assemblies 
 to load, in addition to the usual application base and the GAC. To 
 ensure that you can implicitly import an assembly, put the directory 
 containing the assembly in <code>sys.path</code>. However the 
 <code>Python.Runtime.dll</code> is not loaded from  <code>sys.path</code>.
 It must either live in the GAC or somewhere else were it can be loaded.
</p>

<p>
 The clr module contains some additional methods like <code>setPreload(bool)</code>,
 <code>getPreload()</code>, <code>ListAssemblies(verbosity)</code> and
 <code>FindAssembly(name)</code>. set/getPreload tune the preload flag. For performance
 reasons PythonNet only creates wrappers for classes that are imported. It nakes
 important a bit faster but makes introspection impossible. Interactive Python shells
 have a default of True.
</p>

<a name="classes"></a>

<h2>Using Classes</h2>

<p>
 Python for .NET allows you to use any non-private classes, structs, 
 interfaces, enums or delegates from Python. To create an instance of 
 a managed class, you use the standard instantiation syntax, passing 
 a set of arguments that match one of its public constructors:
</p>

<pre>
    from System.Drawing import Point

    p = Point(5, 5)
</pre>

<p>
 In most cases, Python for .NET can determine the correct constructor 
 to call automatically based on the arguments. In some cases, it may 
 be necessary to call a particular overloaded constructor, which is 
 supported by a special "__overloads__" attribute on a class:
</p>

<pre>
    from System import String, Char, Int32

    s = String.__overloads__[Char, Int32]('A', 10)
</pre>


<a name="generics"></a>

<h2>Using Generics</h2>

<p>
 When running under versions of the .NET runtime greater than 2.0, you can 
 use generic types. A generic type must be bound to create a concrete type 
 before it can be instantiated. Generic types support the subscript syntax 
 to create bound types:
</p>

<pre>
    from System.Collections.Generic import Dictionary
    from System import *

    dict1 = Dictionary[String, String]()
    dict2 = Dictionary[String, Int32]()
    dict3 = Dictionary[String, Type]()
</pre>

<p>
 When you pass a list of types using the subscript syntax, you can also 
 pass a subset of Python types that directly correspond to .NET types:
</p>

<pre>
    dict1 = Dictionary[str, str]()
    dict2 = Dictionary[str, int]()
    dict3 = Dictionary[str, Decimal]()
</pre>

<p>
 This shorthand also works when explicitly selecting generic methods or 
 specific versions of overloaded methods and constructors (explained later).
</p>

<p>
 You can also subclass managed classes in Python, though members of the 
 Python subclass are not visible to .NET code. See the 
 <code>helloform.py</code> file in the <code>/demo</code> directory of the 
 distribution for a simple Windows Forms example that demonstrates 
 subclassing a managed class.
</p>


<a name="fields"></a>

<h2>Fields And Properties</h2>

<p>
 You can get and set fields and properties of CLR objects just as if 
 they were regular attributes:
</p>

<pre>
    from System import Environment

    name = Environment.MachineName
    Environment.ExitCode = 1
</pre>


<a name="indexers"></a>

<h2>Using Indexers</h2>

<p>
 If a managed object implements one or more indexers, you can call 
 the indexer using standard Python indexing syntax:
</p>

<pre>
    from System.Collections import Hashtable

    table = Hashtable()
    table["key 1"] = "value 1"
</pre>

<p>
 Overloaded indexers are supported, using the same notation one 
 would use in C#:
</p>

<pre>
    items[0, 2]

    items[0, 2, 3]
</pre>


<a name="methods"></a>

<h2>Using Methods</h2>

<p>
 Methods of CLR objects behave generally like normal Python methods. 
 Static methods may be called either through the class or through an 
 instance of the class. All public and protected methods of CLR objects 
 are accessible to Python:
</p>

<pre>
    from System import Environment

    drives = Environment.GetLogicalDrives()
</pre>

<p>
 It is also possible to call managed methods <code>unbound</code> (passing the 
 instance as the first argument) just as with Python methods. This is 
 most often used to explicitly call methods of a base class.
</p>

<p>
 <em>Note that there is one caveat related to calling unbound methods: it 
 is possible for a managed class to declare a static method and an 
 instance method with the same name. Since it is not possible for the 
 runtime to know the intent when such a method is called unbound, the 
 static method will always be called.</em>
</p>

<p>
 The docstring of CLR a method (__doc__) can be used to view the 
 signature of the method, including overloads if the CLR method is 
 overloaded. You can also use the Python <code>help</code> method to inspect 
 a managed class:
</p>

<pre>
    from System import Environment

    print Environment.GetFolderPath.__doc__

    help(Environment)
</pre>

<a name="genericmethods"></a>

<h2>Overloaded and Generic Methods</h2>

<p>
 While Python for .NET will generally be able to figure out the right 
 version of an overloaded method to call automatically, there are cases 
 where it is desirable to select a particular method overload explicitly.
</p>

<p>
 Methods of CLR objects have an "__overloads__" attribute that can be used 
 for this purpose:
</p>

<pre>
    from System import Console

    Console.WriteLine.__overloads__[bool](true)
    Console.WriteLine.__overloads__[str]("true")
    Console.WriteLine.__overloads__[int](42)
</pre>

<p>
 Similarly, generic methods may be bound at runtime using the subscript 
 syntax directly on the method:
</p>

<pre>
    someobject.SomeGenericMethod[int](10)
    someobject.SomeGenericMethod[str]("10")
</pre>


<a name="delegates"></a>

<h2>Delegates And Events</h2>

<p>
 Delegates defined in managed code can be implemented in Python. A 
 delegate type can be instantiated and passed a callable Python object 
 to get a delegate instance. The resulting delegate instance is a true 
 managed delegate that will invoke the given Python callable when it 
 is called:
</p>

<pre>
    def my_handler(source, args):
        print 'my_handler called!'

    # instantiate a delegate
    d = AssemblyLoadEventHandler(my_handler)

    # use it as an event handler
    AppDomain.CurrentDomain.AssemblyLoad += d
</pre>


<p>
 Multicast delegates can be implemented by adding more callable objects 
 to a delegate instance:
</p>

<pre>
    d += self.method1
    d += self.method2
    d()
</pre>

<p>
 Events are treated as first-class objects in Python, and behave in 
 many ways like methods. Python callbacks can be registered with event 
 attributes, and an event can be called to fire the event.
</p>

<p>
 Note that events support a convenience spelling similar to that used 
 in C#. You do not need to pass an explicitly instantiated delegate 
 instance to an event (though you can if you want). Events support the 
 <code>+=</code> and <code>-=</code> operators in a way very similar to 
 the C# idiom:
</p>

<pre>
    def handler(source, args):
        print 'my_handler called!'

    # register event handler
    object.SomeEvent += handler

    # unregister event handler
    object.SomeEvent -= handler

    # fire the event
    result = object.SomeEvent(...)
</pre>


<a name="exceptions"></a>

<h2>Exception Handling</h2>

<p>
 You can raise and catch managed exceptions just the same as you would 
 pure-Python exceptions:
<pre>
    from System import NullReferenceException

    try:
        raise NullReferenceException("aiieee!")
    except NullReferenceException, e:
        print e.Message
        print e.Source
</pre>
</p>


<a name="arrays"></a>

<h2>Using Arrays</h2>

<p>
 The type <code>System.Array</code> supports the subscript syntax in order 
 to make it easy to create managed arrays from Python:
</p>

<pre>
    from System import Array

    myarray = Array[int](10)
</pre>

<p>
 Managed arrays support the standard Python sequence protocols:
</p>

<pre>
    items = SomeObject.GetArray()

    # Get first item
    v = items[0]
    items[0] = v

    # Get last item
    v = items[-1]
    items[-1] = v

    # Get length
    l = len(items)

    # Containment test
    test = v in items
</pre>

<p>
 Multidimensional arrays support indexing using the same notation one 
 would use in C#:
</p>

<pre>
    items[0, 2]

    items[0, 2, 3]
</pre>


<a name="collections"></a>

<h2>Using Collections</h2>

<p>
 Managed arrays and managed objects that implement the IEnumerable 
 interface can be iterated over using the standard iteration Python 
idioms:
</p>

<pre>
    domain = System.AppDomain.CurrentDomain

    for item in domain.GetAssemblies():
        name = item.GetName()
</pre>


<a name="com"></a>

<h2>Using COM Components</h2>

<p>
 Using Microsoft-provided tools such as <strong>aximp.exe</strong> and 
 <strong>tlbimp.exe</strong>, it is possible to generate managed wrappers 
 for COM libraries. After generating such a wrapper, you can use the 
 libraries from Python just like any other managed code.
</p>
<p>
 Note: currently you need to put the generated wrappers in the GAC, 
 in the PythonNet assembly directory or on the PYTHONPATH in order 
 to load them.
</p>

<a name="types"></a>

<h2>Type Conversion</h2>

<p>
 Type conversion under Python for .NET is fairly straightforward - most 
 elemental Python types (string, int, long, etc.) convert automatically 
 to compatible managed equivalents (String, Int32, etc.) and vice-versa.
 Note that all strings returned from the CLR are returned as unicode.
</p> 

<p>
 Types that do not have a logical equivalent in Python are exposed as 
 instances of managed classes or structs (System.Decimal is an example).
</p>
<p>
 The .NET architecture makes a distinction between <code>value types</code> 
 and <code>reference types</code>. Reference types are allocated on the heap, 
 and value types are allocated either on the stack or in-line within an 
 object.
</p>

<p>
 A process called <code>boxing</code> is used in .NET to allow code to treat 
 a value type as if it were a reference type. Boxing causes a separate 
 copy of the value type object to be created on the heap, which then 
 has reference type semantics.
</p>

<p>
 Understanding boxing and the distinction between value types and 
 reference types can be important when using Python for .NET because 
 the Python language has no value type semantics or syntax - in 
 Python &quot;everything is a reference&quot;.
</p>

<p>
 Here is a simple example that demonstrates an issue. If you are an 
 experienced C# programmer, you might write the following code:
</p>

<pre>
    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    items[0].X = 1 # won't work!!
</pre>

<p>
 While the spelling of <code>items[0].X = 1</code> is the same in C# and 
 Python, there is an important and subtle semantic difference. In C# (and other
 compiled-to-IL languages), the compiler knows that Point is a value
 type and can do the Right Thing here, changing the value in place.
</p>

<p>
 In Python however, "everything's a reference", and there is really no
 spelling or semantic to allow it to do the right thing dynamically. The
 specific reason that <code>items[0]</code> itself doesn't change is that 
 when you say <code>items[0]</code>, that getitem operation creates a Python 
 object that holds a reference to the object at <code>items[0]</code> via a 
 GCHandle. That causes a ValueType (like Point) to be boxed, so the following 
 setattr (<code>.X = 1</code>) <em>changes the state of the boxed value, not 
 the original unboxed value</em>.
</p>

<p>
 The rule in Python is essentially: &quot;the result of any attribute or 
 item access is a boxed value&quot;, and that can be important in how you 
 approach your code.
</p>

<p>
 Because there are no value type semantics or syntax in Python, you 
 may need to modify your approach. To revisit the previous example, 
 we can ensure that the changes we want to make to an array item 
 aren't "lost" by resetting an array member after making changes 
 to it:
</p>

<pre>
    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    # This _will_ work. We get 'item' as a boxed copy of the Point
    # object actually stored in the array. After making our changes
    # we re-set the array item to update the bits in the array.

    item = items[0]
    item.X = 1
    items[0] = item
</pre>

<p>
 This is not unlike some of the cases you can find in C# where you have
 to know about boxing behavior to avoid similar kinds of <code>lost 
 update</code> problems (generally because an implicit boxing happened that 
 was not taken into account in the code).
</p>

<p>
 This is the same thing, just the manifestation is a little different
 in Python. See the .NET documentation for more details on boxing and 
 the differences between value types and reference types.
</p>


<a name="embedding"></a>

<h2>Embedding Python</h2>

<p>
 <strong>Note:</strong> because Python code running under Python for .NET 
 is inherently unverifiable, it runs totally under the radar of the security 
 infrastructure of the CLR so you should restrict use of the Python assembly 
 to trusted code.
</p>

<p>
 The Python runtime assembly defines a number of public classes that 
 provide a subset of the functionality provided by the Python C API.
</p>

<p>
 These classes include PyObject, PyList, PyDict, etc. The source and 
 the unit tests are currently the only API documentation.. The rhythym 
 is very similar to using Python C++ wrapper solutions such as CXX.
</p>

<p>
 At a very high level, to embed Python in your application you 
 will need to:
</p>

<ul>
<li>Reference Python.Runtime.dll in your build environment</li>
<li>Call PythonEngine.Intialize() to initialize Python</li>
<li>Call PythonEngine.ImportModule(name) to import a module</li>
</ul>


<p>
 The module you import can either start working with your managed app 
 environment at the time its imported, or you can explicitly lookup and 
 call objects in a module you import.
</p>

<p>
 For general-purpose information on embedding Python in applications, use 
 www.python.org or Google to find (C) examples. Because Python for .NET is 
 so closely integrated with the managed environment, you will generally be 
 better off importing a module and deferring to Python code as early as 
 possible rather than writing a lot of managed embedding code.
</p>

<p>
 <strong>Important Note for embedders:</strong> Python is not free-threaded 
 and uses a global interpreter lock to allow multi-threaded applications to 
 interact safely with the Python interpreter. Much more information about 
 this is available in the Python C API documentation on the www.python.org 
 Website.
</p>

<p>
 When embedding Python in a managed application, you have to manage the GIL 
 in just the same way you would when embedding Python in a C or C++ 
 application.
</p>

<p>
 Before interacting with any of the objects or APIs provided by the 
 Python.Runtime namespace, calling code must have acquired the Python
 global interpreter lock by calling the <code>PythonEngine.AcquireLock</code> 
 method. The only exception to this rule is the 
 <code>PythonEngine.Initialize</code> method, which may be called at startup 
 without having acquired the GIL.
</p>

<p>
 When finished using Python APIs, managed code must call a corresponding
 <code>PythonEngine.ReleaseLock</code> to release the GIL and allow other 
 threads to use Python.
</p>

<p>
 The AcquireLock and ReleaseLock methods are thin wrappers over the 
 unmanaged <code>PyGILState_Ensure</code> and <code>PyGILState_Release</code> 
 functions from the Python API, and the documentation for those APIs applies 
 to the managed versions.
</p>


<a name="license" />

<h2>License</h2>

<p>    
 Python for .NET is released under the open source Zope Public License (ZPL). 
 A copy of the ZPL is included in the distribution, or you can find a copy 
 of the 
 <a href="http://pythonnet.sourceforge.net/license.txt"> 
 ZPL online
 </a>. Some distributions of this package include a copy of the C Python
 dlls and standard library, which are covered by the 
 <a href="http://www.python.org/license.html"> 
 Python license
 </a>.
</p>

  </td>
</tr>
</table>

</body>
</html>
